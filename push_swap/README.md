# push_swap

![visualized](https://user-images.githubusercontent.com/79244795/158051111-c4f83332-3f9a-49c4-8fb7-39c7f7b47add.gif)
*200개의 랜덤한 숫자를 넣었을 때 시각화 한 결과*

## 프로젝트 개요
42 본과정의 첫 알고리즘 프로젝트이다.  
### 규칙
a와 b라는 이름의 두개의 스택으로 이루어져 있다. 매개변수로 받는 숫자는 순서대로 a에 쌓이고 이를 오름차순으로 정렬하는것이 목표이다.  
사용되는 연산은 sa,sb,ss,pa,pb,ra,rb,rr,rra,rrb,rrr 각각 s: swap, p: push, r: rotate, rr: reverse rotate. 예를들면 sa하면 a의 가장 위의 두 원소를 서로 바꾼다.
pa: b의 가장 위 원소를 a로 보낸다. ra: a의 원소를 모두 위로 1만큼 올린다. 맨 위는 만 아래로 간다. rra: ra의 반대, rr, rrr은 a,b 모두 적용  
사용되는 연산이 최대한 적게 과제를 풀어야 한다.

## 회고
지금까지 프로젝트 중 가장 어려웠다. 내가 만든 방법으로는 5/3Nlog3N + N 정도의 복잡도가 나오는데(위 결과처럼 200개를 넣으면 약 1800번의 연산이 실행되니 얼추 맞다.) 100점으로 통과하지 못했다.  
알고리즘은 처음이여서 이 참에 쭉 공부해보자 하고 그 유명한 MIT Press의 'Introduction to Algorithms' 샀는데 지금은 책장행이다. 책을 따라가면서 insertion, merge 소트로 과제를 해결해 본 후
피벗을 2개로 한 퀵 소트로 과제를 해결했다.  
약 한달간 과제를 진행했는데 프로젝트가 절대 길게 늘어지면 안된다는걸 절실히 깨달은 프로젝트였다.

### 예전에 코드의 흐름을 정리해 둔 노트

정수를 담을 연결리스트를 생성, 매개변수의 수만큼 정수형 배열을 생성, 각 매개변수를 확인 후 정수임이 확인되면 배열에 담아준다. 배열이 이미 정렬되어있는지 확인 한 후 정렬되어있지 않다면 리스트에 각각의 정수를 담은 노드로 할당해 준다. 그 후 정렬을 해준다. 25 이하는 선택정렬을 이용하여 정렬해주고 그 이상은 피벗이 두개인 퀵소트를 응용하여 정렬해준다.

퀵소트를 응용하여 사용된 알고리즘을 설명하자면, 입력받은 리스트의 상위 r개에 대해 피봇 1, 2를 구한다(피봇은 리스트의 정수를 정렬하여 1/3 2/3 번째의 수를 구한다. 이때에도 퀵소트를 쓴다). 그리고 피봇 2보다 크면 ra로 아래로 넘긴다. 피봇 2보다 작으면 pb로 스택 B로 넘긴다. 이때 넘긴 수가 피봇 1보다 크면 rb로 스택 b의 아래로 넘긴다. 그다음 ra, rb로 넘긴 수들을 rra, rrb로 다시 스택 윗부분에 쌓는다. 이렇게 하면 스택 b는 큰수가 위, 작은수가 아래 오게된다. 그리고 ra의 횟수만큼 방금 시행된 함수를 스택 A에서 재귀로 호출, rb, pb - rb의 횟수만큼 각각 B에서 A로 보내는 다음 설명할 함수를 재귀로 스택에 쌓아둔다. 이렇게 되면 우선적으로 스택 A는 비워지게 되고 스택 B는 아래서부터 위로 작은수부터 큰수의 덩어리들이 쌓이게 된다. A가 비워지면서 재귀로 인해 호출스택에 쌓인 함수들은 함수가 실행될 때의 각각 rb, pb - rb의 횟수를 데이터로 갖게 된다(이 횟수가 r이다). 이 뜻은 스택 B에 피벗으로 나뉘어져 쌓인 정수들의 덩어리가 각각 그에 맞는 개수대로 함수호출을 대기하게 되는 것이다.

스택 B에 쌓인 정수들은 A에 쌓인 정수가 2개 이하일때 점화식이 발동하면서 본격적으로 A로 옮겨지게 되는데 A에서 B로 옮길때와 비슷하게 스택의 상위 r개의 정수에 대해 피벗을 2개 설정하며 여기서는 반대로 피벗 1보다 작으면 rb로 스택 B의 아래로 넘긴다. 그리고 1보다 크면 pa로 A로 보내고 이 때 보낸 A가 피벗 2보다 작으면 ra로 A의 아래로 넘긴다. 이 때 rra와 rrb로 넘긴 정수를 다시 위로 올리기 전에 pa로 보낸 정수 중 ra로 넘어가지 않은 정수들에 대해 다시 첫번째 사용했던 함수로 정렬해준다. 이때 정렬하는 정수들은 pa로 넘어간 정수들 중 피벗 2보다 큰 즉 정렬하는 무리들 중 가장 큰 정수들인데, 이 정수들을 재귀함수를 통해 먼저 정렬해 줌으로서 가장 큰 정수들이 스택 A의 아랫부분에 먼저 정렬되게 하는 것이다. 스택 B 가장 위에있어서 가장 크며 가장 먼저 함수로 호출이 되는 정수들이 스택 A의 가장 아래 정렬된다고 생각하면 이해할 수 있다. 그 후 B에서 A로 보낸 피벗 2 이상의 정수가 정렬이 되어 다시 작동하던 함수로 돌아오면, 이제 아까 미루어 졌던 rra와 rrb로 작아서 내려갔던 정수들을 위로 올려준 뒤 해당 정수의 개수에 맞게 A에서 B로, B에서 A로 재귀함수를 통해 정렬을 반복한다.

내가 썼지만 다시 읽으려니 읽기 싫다.. ㅋㅋㅋ 핵심은 피벗을 기준으로 정수들을 각각 분리하는데, 분리할 때 사용되는 ra, rb, pb 혹은 pa의 수를 매개변수로 사용할 데이터 삼아 재귀함수를 사용하는 것이다.
